# 기능 명세서

- 메뉴
    - 에피타이저
        - 양송이수프(6,000)
        - 타파스(5,500)
        - 시저샐러드(8,000)
    - 메인메뉴
        - 티본스테이크(55,000)
        - 바비큐립(54,000)
        - 해산물파스타(35,000)
        - 크리스마스파스타(25,000)
    - 디저트
        - 초코케이크(15,000)
        - 아이스크림(5,000)
    - 음료
        - 제로콜라(3,000)
        - 레드와인(60,000)
        - 샴페인(25,000)


- 배지
    - 별 (총 혜택 금액 5000원 이상)
    - 트리 (총 혜택 금액 1만원 이상)
    - 산타 (총 혜택 금액 2만원 이상)


- 이벤트
    - 크리스마스 디데이 할인
    - 평일 할인
    - 주말 할인
    - 특별 할인
    - 증정 이벤트


- 날짜 입력
    - 1 ~ 31 사이가 아닐 경우 에러를 발생
    - 문자를 입력하면 에러 발생


- 메뉴 입력
    - 중복된 메뉴 있을 시 에러를 발생
    - 메뉴판에 없는 메뉴 입력 시 에러를 발생
    - 음료만 주문 시 에러를 발생
    - 메뉴의 개수가 1미만이면 에러를 발생
    - 메뉴는 한 번에 최대 20개까지만 주문할 수 있습니다.


- 메뉴 출력
    - 주문한 메뉴 전체 출력


- 할인 전 메뉴 전체 금액 출력


- 증정 메뉴 출력
    - 할인 전 메뉴가 12만원 이상 시 샴페인 증정
    - 증정 메뉴가 없다면 '없음' 으로 출력


- 이벤트 혜택 검사
    - 총주문 금액 10,000원 이상부터 이벤트가 적용됩니다.
    - 날짜 확인
        - 크리스마스 디데이 할인
            - 이벤트 기간: 2023.12.1 ~ 2023.12.25
            - 1,000원으로 시작하여 크리스마스가 다가올수록 날마다 할인 금액이 100원씩 증가
            - 총주문 금액에서 해당 금액만큼 할인
        - 평일 할인 (일요일 ~ 목요일)
            - 디저트 메뉴를 메뉴 1개당 -2,023원
        - 주말 할인 (금요일, 토요일)
            - 주말에는 메인 메뉴를 메뉴 1개당 -2,023원
        - 특별 할인 (일요일, 크리스마스 당일)
            - 이벤트 달력에 별이 있으면 총주문 금액에서 -1,000원
        - 증정 이벤트
            - 할인 전 총주문 금액이 12만 원 이상일 때, -25000원 (샴페인 1개 증정)


- 혜택 내역 출력
    - 적용된 혜택만 출력
      - 오늘 요일이나 날짜가 혜택 범위에 들어가더라도 적용된 가격이 0이라면 출력하지 않는게 맞다고 판단
        - 할인 가격이 0원이라면 이벤트에 추가하지 않는다.
    - 적용된 혜택이 없다면 '없음' 으로 출력


- 총 혜택 금액 출력
    - 적용된 혜택 합산 출력


- 할인 후 예상 결제 금액 출력
    - 할인 전 메뉴 전체 금액 - 총 혜택 금액 출력


- 12월 이벤트 배지 출력
    - 총 혜택 금액 따라 출력
        - 5000원 이상 별
        - 1만원 이상 트리
        - 2만원 이상 산타

# 추가 요구사항

- 입력과 출력을 담당하는 클래스를 별도로 구현한다.
- 해당 클래스의 패키지, 클래스명, 메서드의 반환 타입과 시그니처는 자유롭게 구현할 수 있다.

# 3주차 공통 피드백 내용 정리

### 함수(메서드) 라인에 대한 기준

- 15라인 제한
  - 메소드를 가독성이 좋게 최대한 분리


### 발생할 수 있는 예외 상황에 대한 고민

- 예외사항에 대해 좀 더 고민할 것
  - 이벤트를 추가할 때 이벤트 적용이 되더라도 적용된 가격이 0원이면 이벤트를 추가하지 않는다.
    
    
### 비즈니스 로직과 UI로직을 분리한다.

- 4주차 과제 요구사항
  - 내용을 입력이나 출력을 할 때 컨트롤러를 거쳐가도록 설계
  - 객체 상태를 출력할 땐 toString()를 override를 해서 활용
  - 직접적인 데이터를 보내야할 땐 getter활용
    - **이 부분에 신경을 많이 썼다.**


### 연관성이 있는 상수는 static final이 아닌 enum을 적극 활용

- 여러 클래스에 활용되는 상수들은 enum으로 관리해준다.


### final 키워드를 사용해 값의 변경을 막는다
 
- 최근에 등장하는 프로그래밍 언어들은 기본이 불변값
  - 값의 변경을 막는게 프로그램이 더 안전할 거 같다.


### 객체의 상태 접근을 제한한다

- 인스턴스 변수의 접근 제어자는 private으로 구현한다.
  - 외부에서 값을 쉽게 접근하지 못하도록 하자


### 객체는 객체스럽게 사용하자

- getter를 남발하여 데이터를 꺼내서 값을 제어하지말고 객체 내 메소드를 통해서 원하는 값을 가져오자


### 필드(인스턴스 변수)의 수를 줄이기 위해 노력한다.

- 필드(인스턴스 변수)의 수가 많은 것은 객체의 복잡도를 높이고, 버그 발생 확률이 올라간다.
- 중복이 있거나, 불필요한 필드가 있는지 확인할 것
    
### 성공하는 케이스 뿐만 아니라 예외에 대한 케이스도 테스트한다.

- 성공하는 케이스만 고민하지말고 예외에 대한 부분 또한 처리해야한다.
- 프로그램의 결함이 자주 발생하는 구간은 경계값이다. 

### 테스트코드도 코드다

- 테스트 코드도 코드이므로 리팩토링을 통해 개선해라
  - 하드코딩 하지말자
  - 이번에는 반복문 제어를 통해서 여러 케이스를 한번에 테스트해봤다.
  - **아직 테스트 기능을 활용하는 능력은 부족한 거 같다. 좀 더 공부할 필요가 있다고 봄**


### 테스트를 위한 코드는 구현 코드에서 분리되어야한다.

- 테스트를 위한 편의 메소드를 구현 코드에 구현하지 마라
  - 테스트를 위해 접근제어자 변경
  - 테스트코드에서만 사용되는 메소드
  
### 단위 테스트하기 어려운 코드를 단위 테스트하기

- 구현 방식을 리팩토링해서 단위테스트를 진행한다.
  - 너무 어려운 부분은 테스트하지 않아도 된다.
    - **하지만 최대한 테스트가 가능하도록 구조를 만드는게 좋지 않을까?**

### private 함수를 테스트 하고 싶다면 클래스(객체) 분리를 고려한다.

- 한 객체에게 너무 많은 책임을 주지 말자
- private 메소드가 따로 테스트를 돌려야할 정도로 중요한 로직을 포함한다면 객체 분리를 고려해본다.
  - 그래서 이번엔 좀 더 명확한 책임 분리를 위해 노력했다.